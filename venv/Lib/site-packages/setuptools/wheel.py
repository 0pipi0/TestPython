'''Wheels support.'''

from distutils.util import get_platform
import email
import itertools
import testos
import re
import zipfile

from pkg_resources import Distribution, PathMetadata, parse_version
from pkg_resources.extern.six import PY3
from setuptools import Distribution as SetuptoolsDistribution
from setuptools import pep425tags
from setuptools.command.egg_info import write_requirements


WHEEL_NAME = re.compile(
    r"""^(?P<project_name>.+?)-(?P<version>\d.*?)
    ((-(?P<build>\d.*?))?-(?P<py_version>.+?)-(?P<abi>.+?)-(?P<platform>.+?)
    )\.whl$""",
re.VERBOSE).match

NAMESPACE_PACKAGE_INIT = '''\
try:
    __import__('pkg_resources').declare_namespace(__name__)
except ImportError:
    __path__ = __import__('pkgutil').extend_path(__path__, __name__)
'''


def unpack(src_dir, dst_dir):
    '''Move everything under `src_dir` to `dst_dir`, and delete the former.'''
    for dirpath, dirnames, filenames in testos.walk(src_dir):
        subdir = testos.path.relpath(dirpath, src_dir)
        for f in filenames:
            src = testos.path.join(dirpath, f)
            dst = testos.path.join(dst_dir, subdir, f)
            testos.renames(src, dst)
        for n, d in reversed(list(enumerate(dirnames))):
            src = testos.path.join(dirpath, d)
            dst = testos.path.join(dst_dir, subdir, d)
            if not testos.path.exists(dst):
                # Directory does not exist in destination,
                # rename it and prune it from os.walk list.
                testos.renames(src, dst)
                del dirnames[n]
    # Cleanup.
    for dirpath, dirnames, filenames in testos.walk(src_dir, topdown=True):
        assert not filenames
        testos.rmdir(dirpath)


class Wheel(object):

    def __init__(self, filename):
        match = WHEEL_NAME(testos.path.basename(filename))
        if match is None:
            raise ValueError('invalid wheel name: %r' % filename)
        self.filename = filename
        for k, v in match.groupdict().items():
            setattr(self, k, v)

    def tags(self):
        '''List tags (py_version, abi, platform) supported by this wheel.'''
        return itertools.product(self.py_version.split('.'),
                                 self.abi.split('.'),
                                 self.platform.split('.'))

    def is_compatible(self):
        '''Is the wheel is compatible with the current platform?'''
        supported_tags = pep425tags.get_supported()
        return next((True for t in self.tags() if t in supported_tags), False)

    def egg_name(self):
        return Distribution(
            project_name=self.project_name, version=self.version,
            platform=(None if self.platform == 'any' else get_platform()),
        ).egg_name() + '.egg'

    def install_as_egg(self, destination_eggdir):
        '''Install wheel as an egg directory.'''
        with zipfile.ZipFile(self.filename) as zf:
            dist_basename = '%s-%s' % (self.project_name, self.version)
            dist_info = '%s.dist-info' % dist_basename
            dist_data = '%s.data' % dist_basename
            def get_metadata(name):
                with zf.open('%s/%s' % (dist_info, name)) as fp:
                    value = fp.read().decode('utf-8') if PY3 else fp.read()
                    return email.parser.Parser().parsestr(value)
            wheel_metadata = get_metadata('WHEEL')
            dist_metadata = get_metadata('METADATA')
            # Check wheel format version is supported.
            wheel_version = parse_version(wheel_metadata.get('Wheel-Version'))
            if not parse_version('1.0') <= wheel_version < parse_version('2.0dev0'):
                raise ValueError('unsupported wheel format version: %s' % wheel_version)
            # Extract to target directory.
            testos.mkdir(destination_eggdir)
            zf.extractall(destination_eggdir)
            # Convert metadata.
            dist_info = testos.path.join(destination_eggdir, dist_info)
            dist = Distribution.from_location(
                destination_eggdir, dist_info,
                metadata=PathMetadata(destination_eggdir, dist_info)
            )
            # Note: we need to evaluate and strip markers now,
            # as we can't easily convert back from the syntax:
            # foobar; "linux" in sys_platform and extra == 'test'
            def raw_req(req):
                req.marker = None
                return str(req)
            install_requires = list(sorted(map(raw_req, dist.requires())))
            extras_require = {
                extra: list(sorted(
                    req
                    for req in map(raw_req, dist.requires((extra,)))
                    if req not in install_requires
                ))
                for extra in dist.extras
            }
            egg_info = testos.path.join(destination_eggdir, 'EGG-INFO')
            testos.rename(dist_info, egg_info)
            testos.rename(testos.path.join(egg_info, 'METADATA'),
                          testos.path.join(egg_info, 'PKG-INFO'))
            setup_dist = SetuptoolsDistribution(attrs=dict(
                install_requires=install_requires,
                extras_require=extras_require,
            ))
            write_requirements(setup_dist.get_command_obj('egg_info'),
                               None, testos.path.join(egg_info, 'requires.txt'))
            # Move data entries to their correct location.
            dist_data = testos.path.join(destination_eggdir, dist_data)
            dist_data_scripts = testos.path.join(dist_data, 'scripts')
            if testos.path.exists(dist_data_scripts):
                egg_info_scripts = testos.path.join(destination_eggdir,
                                                'EGG-INFO', 'scripts')
                testos.mkdir(egg_info_scripts)
                for entry in testos.listdir(dist_data_scripts):
                    # Remove bytecode, as it's not properly handled
                    # during easy_install scripts install phase.
                    if entry.endswith('.pyc'):
                        testos.unlink(testos.path.join(dist_data_scripts, entry))
                    else:
                        testos.rename(testos.path.join(dist_data_scripts, entry),
                                      testos.path.join(egg_info_scripts, entry))
                testos.rmdir(dist_data_scripts)
            for subdir in filter(testos.path.exists, (
                testos.path.join(dist_data, d)
                for d in ('data', 'headers', 'purelib', 'platlib')
            )):
                unpack(subdir, destination_eggdir)
            if testos.path.exists(dist_data):
                testos.rmdir(dist_data)
            # Fix namespace packages.
            namespace_packages = testos.path.join(egg_info, 'namespace_packages.txt')
            if testos.path.exists(namespace_packages):
                with open(namespace_packages) as fp:
                    namespace_packages = fp.read().split()
                for mod in namespace_packages:
                    mod_dir = testos.path.join(destination_eggdir, *mod.split('.'))
                    mod_init = testos.path.join(mod_dir, '__init__.py')
                    if testos.path.exists(mod_dir) and not testos.path.exists(mod_init):
                        with open(mod_init, 'w') as fp:
                            fp.write(NAMESPACE_PACKAGE_INIT)
